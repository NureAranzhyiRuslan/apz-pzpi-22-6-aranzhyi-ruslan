МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ




Практична робота №1


з дисципліни
«Архітектура програмного забезпечення»







Харків 2025

1 ПАТТЕРНИ ПРОЄКТУВАННЯ
1.1 Історія змін
Зміни звіту наведені у таблиці 1.1.
Таблиця 1.1 - Історія змін
№	Дата	Версія звіту	Опис змін
1	01.04.2025	0.1	Створено розділ “Історія змін”
2	01.04.2025	0.1	Створено розділ “Завдання”
3	01.04.2025	0.1	Створено розділ “Опис виконаної роботи”
4	01.04.2025	0.1	Створено розділ “Висновки”
5	04.04.2025	0.1	Додані слайди презентації у Додаток Б
6	04.04.2025	0.1	Додані приклади програмного коду у Додаток А
7	05.04.2025	0.1	Додані посилання і хронологічний опис доповіді у Додаток А

1.2 Завдання
Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
Створити та оформити слайди презентації доповіді
Створити та опублікувати на YouTube відеозапис доповіді
Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1

1.3 Опис виконаної роботи
Патерн Iterator та яку проблему він вирішує
Iterator - це поведінковий патерн проектування, який дозволяє обходити елементи колекції, не розкриваючи її базового представлення (список, стек, дерево тощо).
Патерн «Iterator» вирішує проблему доступу до елементів у будь-якому контейнері у певному порядку і без повторень елементів (наприклад, у таких структурах як циклічні графи).
Структура патерну
Патерн Iterator - це інтерфейс, який має методи для отримання наступного елементу або інформації про те, чи є взагалі елементи у контейнері, які ще не були повернуті ітератором.
Класи реалізації патерну зберігають контейнер, елементи якого потрібно проітерувати, поточний стан проходження контейнеру та реалізують методи, описані вище. Методи, зазвичай, мають назви getNext та hasNext.
Використання патерну
У коді, у якому потрібно проітерувати по елементам деякої колекції, потрібно створити об’єкт ітератора та викликати метод getNext до тих пір, поки hasNext повертає true. Коли hasNext повертає false - це означає, що у ітераторі закінчилися елементи, які ще не були повернуті і ітерацію по елементам колекції потрібно зупинити.
Переваги патерну
Принцип єдиної відповідальності: завдяки патерну “Iterator” можна очистити код і колекції, виділивши громіздкі алгоритми обходу в окремі класи.
Оскільки всі ітератори реалізують один інтерфейс, можливо реалізовувати нові типи колекцій та ітераторів і передавати їх в існуючий код, нічого не ламаючи.
Патерн “Iterator” дозволяє виконувати ітерації над однією і тією ж колекцією паралельно, оскільки кожен об'єкт ітератора містить власний стан ітерації.
З тієї ж причини можливо затримати ітерацію і продовжити її, коли це буде потрібно.
Недоліки патерну
Застосування патерну “Iterator” може бути надмірним, якщо програма працює лише з простими колекціями.
Використання ітератора може бути менш ефективним, ніж безпосередній доступ до елементів деяких специфічних колекцій.
Приклад коду реалізації патерну
Приклад реалізації та використання патерну «Iterator» на мові програмування Java наведений у Додатку В.
Рекомендації щодо використання патерну
Використовуйте патерн “Iterator”, коли колекція має складну структуру даних, але потрібно приховати її складність.
Використовуйте паттерн, щоб зменшити дублювання коду обходу у програмі.
Використовуйте ітератор, коли ви хочете, щоб ваш код міг обходити різні структури даних або коли типи цих структур заздалегідь невідомі.

1.4 Висновки
Код нетривіальних ітераційних алгоритмів, як правило, дуже громіздкий. Якщо його розмістити в бізнес-логіці програми, він може розмити відповідальність за оригінальний код і зробити його менш придатним для супроводу. Перенесення коду обходу до ітераторів може допомогти зробити код програми більш легким і чистим.
Ітератор інкапсулює деталі роботи зі складною структурою даних, надаючи кілька простих методів доступу до елементів колекції. Окрім того, що такий підхід дуже зручний для тих, хто використовує код, він також захищає колекцію від необережних або зловмисних дій, які могли бути виконані, якща працювати з колекцією безпосередньо


Додаток А
Посилання на відео та хронологічний опис

Відео доповіді на YouTube: https://youtu.be/CXiDnxyTtgo
Хронологічний опис доповіді:
00:00 Вступ
00:11 Що таке патерн "Ітератор" та яку проблему він вирішує
01:27 Структура патерну
03:04 Використання патерну
03:44 Переваги ітераторів
05:06 Недоліки ітераторів
05:35 Приклад коду реалізації класу патерну "Ітератор" 
06:35 Праклад коду використання патерну "Ітератор"
07:16 Вступ
08:08 Висновки
08:57 Список використаних джерел

Додаток Б
Слайди презентації №1


Рисунок Б.1 - Титульний слайд презентації

Рисунок Б.2 - Визначення патерну «Iterator» та проблем, які він вирішує

Рисунок Б.3 - Структура патерну

Рисунок Б.4 - Опис використання патерну

Рисунок Б.5 - Переваги патерну

Рисунок Б.6 - Недоліки патерну

Рисунок Б.7 - Приклад програмного коду з реалізацією патерну «Iterator»

Рисунок Б.8 - Приклад програмного коду з використання патерну «Iterator»

Рисунок Б.9 - Рекомендації щодо використання патерну

Рисунок Б.10 - Висновки

Рисунок Б.11 - Слайд презентації «Використані джерела»


Додаток В
Приклад коду реалізації патерну «Iterator» на мові програмування Java

     1  interface Iterator<E> {
     2      boolean hasNext();
     3      E next();
     4  }
     5  
     6  public class LinkedListIterator<T> implements Iterator<T> {
     7      private LinkedListNode<T> current;
     8  
     9      LinkedListIterator(LinkedListNode<T> head) {
    10          current = head;
    11      }
    12  
    13      @Override
    14      public boolean hasNext() {
    15          return current != null;
    16      }
    17  
    18      @Override
    19      public T next() {
    20          if(current == null) {
    21              throw new IllegalStateException();
    22          }
    23          LinkedListNode<T> ret = current;
    24          current = current.next;
    25          return ret.value;
    26      }
    27  }
